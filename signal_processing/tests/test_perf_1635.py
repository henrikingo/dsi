"""
QHat related tests.
"""
from __future__ import print_function
import unittest

import itertools
import numpy as np
from signal_processing.qhat import QHat

from bin.common.log import setup_logging

setup_logging(False)


class CanonicalQHat(object):
    #pylint: disable=invalid-name, too-many-locals, too-many-branches
    """
    This is the original O(n^2) Qhat implementation as described in the whitepaper.
    It is here for comparison purposes only and to allow the q values to
    be generated if further tests are added.

    NOTE: This is why I have disabled some pylint checks.
    NOTE: This implementation is purely to provide a 'canonical' implementation for
    test purposes. It is not efficient and will not be optimized.
    """

    def __init__(self):
        self.average_value = 0
        self.average_diff = 0
        self.t = 0

    # Implementing change-point detection algorithm from https://arxiv.org/pdf/1306.4933.pdf
    def qs(self, series):
        """
        Find Q-Hat values for all candidate change points

        :param list series: the points to process
        :return:
        """
        t = len(series)
        self.t = t
        if t < 5:
            # Average value and average diff are used even when there is no data.
            # This avoids an error.
            self.average_value = 1
            self.average_diff = 1
            return [0] * t
        n = 2
        m = t - n
        qs = [0, 0]  # represents q when n = 0, 1
        # The following line could safely replace the next 6 lines
        #diffs = [[abs(series[i] - series[j]) for i in range(t)] for j in range(t)]
        diffs = [None] * t
        for i in range(t):
            diffs[i] = [0] * t
        for i in range(t):
            for j in range(t):
                diffs[i][j] = abs(series[i] - series[j])

        term1 = 0.0  # sum i:0-n, j:n-t, diffs[i][j]
        term2 = 0.0  # sum i:0-n, k:(i+1)-n, diffs[i][k]
        term3 = 0.0  # sum j:n-t, k:(j+i)-t, diffs[j][k]

        # Normalization constants
        self.average_value = np.average(series)
        # I'm sure there's a better way than this next line, but it works for now
        self.average_diff = np.average(list(itertools.chain(*diffs)))
        # term1 = sum(diffs[i][j] for i in range(n) for j in range(n,t))
        for i in range(n):
            for j in range(n, t):
                term1 += diffs[i][j]
        # term2 = sum(diffs[i][k] for i in range(n) for k in range(i+1,n))
        for i in range(n):
            for k in range((i + 1), n):
                term2 += diffs[i][k]
        # term3 = sum(diffs[j][k] for j in range(n, t) for k in range(j+1,t))
        for j in range(n, t):
            for k in range((j + 1), t):
                term3 += diffs[j][k]

        term1_reg = term1 * (2.0 / (m * n))
        term2_reg = term2 * (2.0 / (n * (n - 1)))
        term3_reg = term3 * (2.0 / (m * (m - 1)))
        newq = (m * n / (m + n)) * (term1_reg - term2_reg - term3_reg)
        qs.append(newq)

        for _ in range(3, (t - 2)):
            term1 = 0
            term2 = 0
            term3 = 0

            n += 1
            m = t - n
            for i in range(n):
                for j in range(n, t):
                    term1 += diffs[i][j]
            for i in range(n):
                for k in range((i + 1), n):
                    term2 += diffs[i][k]
            for j in range(n, t):
                for k in range((j + 1), t):
                    term3 += diffs[j][k]

            term1_reg = term1 * (2.0 / (m * n))
            term2_reg = term2 * (2.0 / (n * (n - 1)))
            term3_reg = term3 * (2.0 / (m * (m - 1)))
            newq = (m * n / (m + n)) * (term1_reg - term2_reg - term3_reg)

            qs.append(newq)

        qs.append(0)
        qs.append(0)
        return qs


def plot(series, qhat_values, duration=None, name=None):
    """
    Generate a plot for series and qhat_values (on different scales). This
    can be useful for 'eye-balling' the results.

    :param list(float) series: The timeseries data.
    :param list(float) qhat_values: The qhat values generated from series.
    :param float duration: The duration is seconds (if available).
    :param str name: The algorithm identifier (if available).
    """
    import matplotlib.pyplot as plt
    _, ax1 = plt.subplots()
    if name is None and duration is None:
        plt.suptitle('{}: {} s'.format(name, duration))

    position = np.argmax(qhat_values)
    x_values = range(len(series))
    ax1.plot(x_values, qhat_values, 'r-')

    ax2 = ax1.twinx()
    ax2.plot(x_values, series, 'b--')
    plt.axvline(x=position)
    plt.show()


class TestPerf1635Simple(unittest.TestCase):
    """
    Test PERF-1635 is fixed correctly.
    """

    def setUp(self):
        """
        Common test setup.
        """
        self.series = np.array([1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3], dtype=np.float)
        self.expected = np.array(
            [
                0, 0, 1.3777777777777778, 3.4444444444444438, 4.428571428571429, 2.971428571428571,
                3.599999999999999, 2.342857142857143, 2.857142857142857, 4.666666666666666, 0, 0
            ],
            dtype=np.float)

    def test_old_algorithm(self):
        """
        Test to double check slow O(n^2) algorithm. Small data set so this is ok.
        """
        algorithm = CanonicalQHat()
        q_values = algorithm.qs(self.series)
        self.assertTrue(all(np.isclose(self.expected, q_values)))

    def test_fixed(self):
        """
        Test that the current algorithm generates the same q values as the original.
        """
        algorithm = QHat({})
        q_values = algorithm.qhat_values(self.series)
        self.assertTrue(all(np.isclose(self.expected, q_values)))


class TestPerf1635(unittest.TestCase):
    """
    Robust test for PERF-1635.
    """

    def setUp(self):
        """
        Common test setup.
        """
        self.series = np.array(
            [
                28681.119699779538, 29161.132432282106, 28751.110477423033, 29028.735950390343,
                28497.939926293933, 29199.786134378897, 29262.858259146597, 28982.36032261096,
                29047.87496329457, 28803.23473827627, 28784.416639673225, 28393.455762492486,
                28299.35497800448, 28839.5170384224, 29119.992890626734, 28438.58145564608,
                28890.848174925057, 29495.310908957937, 28790.423107547842, 28912.515992411878,
                29021.82637431983, 28621.777724399217, 28643.826111660484, 29070.907356887794,
                28425.321506798813, 30793.73656450798, 30688.113132448314, 31276.128662785148,
                30480.974390279353, 31417.630949741426, 30504.02909090909, 31208.547873448613,
                31214.67951084174, 30480.265567499377, 31383.21561115767, 31012.865635444086,
                31109.291465665072, 30928.708373890215, 30275.913841889473, 30705.18714604478,
                30319.15939464386, 31329.20620503382, 30528.718498159968, 31226.020095175132,
                31271.83800065611, 30936.55589123867, 30360.418789956453, 30847.00289473065,
                30935.8257216361, 30462.555705977025, 31029.01750045867, 30936.373345606677,
                30841.196263441492, 30553.98207396529, 30008.35651407443, 30802.96345038688,
                30819.803190801464, 30066.522915997615, 30694.76075336491, 30337.580576097396,
                30890.804428392144, 31017.45252322073, 30542.946357831945, 30454.94679120777,
                29978.157699125164, 29776.232990299643, 29825.525499900446, 30127.338757872476,
                29651.950637392965, 29279.36380288612, 28784.416639673225, 28290.803524694988,
                28758.04947616697, 28778.096748873384, 28252.53809842002, 28112.560054907342,
                28778.88658345135, 29809.58499877757, 29479.55557554766, 29226.48114701095,
                29239.03162661521, 28934.535701277055, 28529.575012243564, 29107.705973795248,
                28153.31908541235, 29050.450200858846, 29226.15530408607, 28943.001462916447,
                28804.02595333454, 29037.57857716485, 29040.47369791234, 29445.94526287412,
                28496.5458765212, 29039.02606537946, 28429.329024281793, 28340.351465158896,
                28766.09659879622, 28597.111314744514, 29118.375598431583, 28133.377692398502,
                28029.446829440414, 28353.992255608195, 28795.483130392753, 29469.116580762293,
                29663.358718160525, 28224.85653068036, 29535.688130246184, 29101.889473567353,
                28562.058389309277, 28710.332780251134, 28246.145226114408, 28859.042670306928,
                28582.300701626224, 28433.029274271397, 30554.33819758497, 31047.208470521353,
                31394.115040538436, 31422.526685485853, 30932.17539056969, 31003.512589736616,
                31061.18773401583, 31548.64487555962, 30795.18355359765, 31391.295496865587,
                31972.094668349768, 31366.317678731677, 31805.872361077407, 31379.271131965932,
                31628.58039139982, 31051.62161521878, 31487.255867585944, 31509.964660913047,
                31818.2259552362, 32071.840609764302, 30673.929196187757, 31094.346784333262,
                31294.984211877203, 30788.853980092197, 30640.764897024103, 31253.94185429595,
                31182.19071352528, 30762.478657051826, 31510.911571494686, 31193.3221083194,
                31381.90067457966, 31918.37281366622, 31251.70627611571, 31477.992519077554,
                31382.652053416976, 31137.92939611346, 31395.807009874665, 30427.37423683172,
                30250.235118309225, 31045.73770103508, 30794.460042054812, 31182.747094579325,
                31161.618563073556, 31252.824025226964, 31051.62161521878, 32146.36957828001,
                31197.591250431407, 31185.90029562745, 31264.005915430807, 31332.576346142352,
                31132.752191159354, 31207.061778658714, 31418.007490636704, 31626.863240696614,
                31450.235147327, 30874.61427932066, 31684.202256561493, 31369.508116290617,
                31900.6997261941
            ],
            dtype=np.float)
        self.expected = np.array(
            [
                0, 0, 1020.0976339462109, 2499.3041214852033, 3739.4820463956921,
                5292.0711377378466, 6275.4938770568169, 7233.2631845555561, 8654.5636576183533,
                10076.823642106745, 11694.524433663953, 13408.406595465964, 15176.028931296149,
                17108.331646794577, 17485.387386276292, 18904.141597839258, 20996.048824772781,
                22867.615308946537, 23405.619796937288, 23975.946016593527, 25929.473757196021,
                27771.143858991782, 30048.022955033601, 30791.324816810789, 32658.445427276361,
                35165.412034836125, 32735.267045292767, 29359.723988890983, 26723.310743282247,
                25456.075944948479, 22074.862101748142, 21033.682033001649, 19073.180271084118,
                16605.213937139335, 15854.960614762887, 13658.044899590837, 12395.711829446278,
                11137.154026602111, 9767.431605058815, 9493.5481449116833, 8534.0869100599757,
                8318.8454593414281, 6985.2480925605232, 6648.0675458298429, 5561.2006789691732,
                4721.5879620637506, 4011.4766497451319, 3906.5658748537981, 3365.5111002437452,
                2920.9578470189181, 2762.5917213638795, 2255.9902988041767, 1942.2868352367032,
                1676.7715845583853, 1654.9174332199702, 1743.0064541748286, 1583.0148304696775,
                1500.984721393947, 1630.8113220542364, 1623.1032751572425, 1819.8241357443781,
                1740.6702879631055, 1590.3562124021912, 1804.733906212814, 2032.1405729483558,
                2246.490691865647, 2454.8791788947892, 2776.8273283788153, 3092.9273102566262,
                3377.0292649296953, 3650.2581504484783, 3899.1012353399583, 4201.3283044564096,
                4595.0027934796635, 5063.8213890218994, 5511.1109502331792, 6054.0210419622381,
                6727.3910734197489, 7148.6259652161243, 7690.2940774829367, 8550.2170995114666,
                9278.2058844211679, 10132.450184722447, 11059.961268517243, 11979.779545864956,
                13035.392378651393, 14093.175852296261, 15129.134379488134, 16353.431720498389,
                17691.042930610147, 19019.65091195429, 20423.581023549265, 21549.866113942746,
                23168.09349883665, 24209.528618858691, 25983.669175484149, 27885.144523303323,
                29858.599862653889, 31976.465407446354, 33917.876372926847, 36297.701058130748,
                38862.080562095296, 40585.309682792416, 43211.261114861052, 45077.350817889353,
                46708.428463614073, 49887.462998764444, 50686.995459026002, 53533.168525957153,
                56991.335274795529, 60575.958419736889, 62973.914742519468, 66756.976086916125,
                71001.092105618824, 73663.305544015908, 74044.770457059683, 73077.576618429608,
                69537.215686733325, 67925.508141957311, 67397.981292425946, 64917.017312650365,
                64141.390611651208, 60806.727143020486, 60808.57153196798, 59458.199570769866,
                56125.845436452735, 54890.844069987907, 51802.921339907625, 50627.719500723862,
                47790.242381476804, 47266.692598958936, 44635.809478309689, 43492.964621901643,
                40881.763429548955, 39688.714916992736, 38780.219885902246, 38264.391722641732,
                36120.92523091624, 35070.284805989482, 35739.704578741919, 33731.292964440931,
                33169.691806814844, 32374.676011871128, 30244.141938035693, 29738.136432052357,
                27778.072100857938, 25694.075527008768, 25133.226339736259, 23271.277730557849,
                21528.39198102403, 20110.430990455694, 19489.145923047792, 19654.175011211315,
                20287.842811161667, 19152.116940629319, 19931.879667373418, 18540.363564281386,
                17248.366391074233, 15826.548683720117, 14904.702942620876, 14296.200907941209,
                13059.560574945246, 11909.944462573987, 10645.053364318814, 9292.1952035790473,
                8426.8258561541516, 7478.1767872516239, 6071.355486504649, 4419.6093477596432,
                3071.5486883966387, 2942.2108652239694, 0, 0
            ],
            dtype=np.float)

    def test_q_values(self):
        """
        Test that the current algorithm generates the same q values as the original.
        """
        algorithm = QHat({})
        q_values = algorithm.qhat_values(self.series)
        self.assertTrue(all(np.isclose(self.expected, q_values)))
